{
  "name": "CPrimer",
  "tagline": "Notes and pieces of code concerning the C++ Primer book",
  "body": "# C++ Primer - Chapters summaries and notes\r\n\r\n## Getting started\r\n\r\nExample of a program that uses the IO library:\r\n\r\n    #include <iostream>\r\n    /*\r\n     * Simple main function:\r\n     * read two numbers and write their sum\r\n     */\r\n    int main()\r\n    {\r\n      // prompt user to enter two numbers\r\n      std::cout << \"Enter two numbers:\" << std::endl;\r\n      int v1 = 0, v2 = 0; // variables to hold the input we read\r\n      std::cin >> v1 >> v2; // read input\r\n      std::cout << \"The sum of \" << v1 << \" and \" << v2\r\n                << \" is \" << v1 + v2 << std::endl;\r\n      return 0;\r\n    }\r\n(ignore this : .*)\r\n\r\n## Variables and Basic Types\r\n\r\n### References\r\n\r\nA **reference** defines an alternative name for an object. A reference type “refers to” another type. We define a reference type by writing a declarator of the form `&d`, where `d` is the name being declared:\r\n\r\n    int ival = 1024;\r\n    int &refVal = ival; // refVal refers to (is another name for) ival\r\n    int &refVal2 = ival // error: a reference must be initialized\r\n\r\n### Pointers\r\n\r\nA **pointer** is a compound type that “points to” another type. Like references, pointers are used for indirect access to other objects. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need not be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.\r\n\r\n    int ival = 42;\r\n    int *p = &ival; // p holds the address of ival; p is a pointer to ival\r\n    cout << *p;     // * yields the object to which p points; prints 42\r\n(ignore this : .*)\r\n\r\n### Summary\r\n\r\nTypes are fundamental to all programming in C++.\r\n\r\nEach type defines the storage requirements and the operations that may be performed on objects of that type. The language provides a set of fundamental built-in types such as `int` and `char`, which are closely tied to their representation on the machine’s hardware. Types can be non`const` or `const`; a `const` object must be initialized and, once initialized, its value may not be changed. In addition, we can define compound types, such as pointers or references. A compound type is one that is defined in terms of another type.\r\n\r\nThe language lets us define our own types by defining classes. The library uses the class facility to provide a set of higher-level abstractions such as the IO and `string` types.\r\n\r\n## Strings, Vectors, and Arrays\r\n\r\nAmong the most important library types are `vector` and `string`. A `string` is a variable-length sequence of characters, and a `vector` is a container of objects of a single type.\r\n\r\nIterators allow indirect access to objects stored in a container. Iterators are used to access and navigate between the elements in `string`s and `vector`s.\r\n\r\nArrays and pointers to array elements provide low-level analogs to the `vector` and `string` libraries. In general, the library classes should be used in preference to low-level array and pointer alternatives built into the language.\r\n\r\n## Functions\r\n\r\nFunctions are named units of computation and are essential to structuring even modest programs. Every function has a return type, a name, a (possibly empty) list of parameters, and a function body. The function body is a block that is executed when the function is called. When a function is called, the arguments passed to the function must be compatible with the types of the corresponding parameters.\r\n\r\nIn C++, functions may be overloaded: The same name may be used to define different functions as long as the number or types of the parameters in the functions differ. The compiler automatically figures out which function to call based on the arguments in a call. The process of selecting the right function from a set of overloaded functions is referred to as function matching.\r\n\r\n## Classes\r\n\r\nClasses are the most fundamental feature in C++. Classes let us define new types for our applications, making our programs shorter and easier to modify.\r\n\r\nData abstraction—the ability to define both data and function members—and encapsulation—the ability to protect class members from general access—are fundamental to classes. We encapsulate a class by defining its implementation members as `private`. Classes may grant access to their non`public` member by designating another class or function as a friend.\r\n\r\nClasses may define constructors, which are special member functions that control how objects are initialized. Constructors may be overloaded. Constructors should use a constructor initializer list to initialize all the data members.\r\n\r\nClasses may also define `mutable` or `static` members. A `mutable` member is a data member that is never `const`; its value may be changed inside a `const` member function. A `static` member can be either function or data; `static` members exist independently of the objects of the class type.\r\n\r\n## The IO Library\r\n\r\n3 headers : `iostream` for streams, `fstream` for files and `sstream` for `string`s\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}